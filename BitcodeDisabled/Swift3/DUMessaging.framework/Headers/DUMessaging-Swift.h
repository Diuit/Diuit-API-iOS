// Generated by Apple Swift version 3.0 (swiftlang-800.0.46.2 clang-800.0.38)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import Foundation;
@import SocketIO;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class DUChannel;

/**
  Class for announcement in Diuit API. In APP, you can only list announcements. Creat, update and delete announce must be operated on server side.
*/
SWIFT_CLASS("_TtC11DUMessaging10DUAnnounce")
@interface DUAnnounce : NSObject
/**
  Announcement id.
*/
@property (nonatomic, readonly) NSInteger id;
/**
  Type of announcement.
*/
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/**
  The keywords used for querying announcements.
*/
@property (nonatomic, readonly, copy) NSString * _Nullable type;
/**
  The keywords used for querying announcements.
*/
@property (nonatomic, readonly, copy) NSString * _Nullable keywords;
/**
  Content of announcement.
*/
@property (nonatomic, readonly, copy) NSString * _Nullable body;
/**
  Any extra information of this announcement.
*/
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;
/**
  Creation time.
*/
@property (nonatomic, readonly, copy) NSDate * _Nullable createdAt;
/**
  Last updated time
*/
@property (nonatomic, readonly, copy) NSDate * _Nullable updatedAt;
/**
  The \code
  DUChannel
  \endcode object that this announcement belongs to. Always create a new instance here. Each announcement belongs to one channel.
  seealso:
  \code
  DUChannel
  \endcode
*/
@property (nonatomic, readonly, strong) DUChannel * _Nullable channel;
/**
  If this announcement comes with a push notification.
*/
@property (nonatomic, readonly) BOOL hasNotification;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


/**
  Class for channel in Diuit API.
*/
SWIFT_CLASS("_TtC11DUMessaging9DUChannel")
@interface DUChannel : NSObject
/**
  Channel id.
*/
@property (nonatomic, readonly) NSInteger id;
/**
  Title of this channel.
*/
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

enum DUChatType : NSInteger;
@class DUMessage;
@class NSError;
enum DUTypingIndicator : NSInteger;
@class UIImage;

/**
  Class for chat rooms. You can list historical messages, manage properties and send messages via this class.
*/
SWIFT_CLASS("_TtC11DUMessaging6DUChat")
@interface DUChat : NSObject
/**
  Id of the chat room.
*/
@property (nonatomic, readonly) NSInteger id;
/**
  Indicates if this chat room is a direct or group chat room.
*/
@property (nonatomic, readonly) enum DUChatType type;
/**
  Last message in this chat room.
*/
@property (nonatomic, strong) DUMessage * _Nullable lastMessage;
/**
  User serials in this chat room.
*/
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable members;
/**
  User serials that are allowed to be in this chat room. Set to nil to allow everyone.
*/
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable whiteList;
/**
  Extra information of the chat room.
*/
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;
/**
  If you can receive push notification. Use \code
  enablePushNotification
  \endcode or \code
  disablePushNotification
  \endcode to enable or disable.
*/
@property (nonatomic, readonly) BOOL pushEnabled;
/**
  This property is only for direct chat rooms to indicate if you block another user. In a group chat room, this value will always be false.
*/
@property (nonatomic, readonly) BOOL isBlockedByMe;
/**
  Count of unread messages in this chat room.
*/
@property (nonatomic, readonly) NSInteger unreadMessageCount;
@property (nonatomic, readonly) NSNotificationName _Nonnull notificationNameForReceivingMessage;
/**
  Update meta of the chat room.
  \param meta Any extra information of the chat room, such as name.

  \param onCompletion completion: The closure object to be executed when the task finishes successfully. It will return an \code
  NSError
  \endcode and a \code
  DUChat
  \endcode object. Former will not be nil when there’s any error happening; later will be the updated self.

*/
- (void)updateWithMeta:(NSDictionary<NSString *, id> * _Nullable)meta onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;
/**
  Update white list of the chat room. Only users on the list can join this room. <em>Set to nil if you’d like to allow all users</em>.
  \param whiteList User serials of allowed users.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an \code
  NSError
  \endcode and a \code
  DUChat
  \endcode object. Former will not be nil when there’s any error happening; later will be the updated self.

*/
- (void)updateWithWhiteList:(NSArray<NSString *> * _Nullable)whiteList onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;
/**
  Enable to receive push notification. You can check current state in property \code
  pushEanbled
  \endcode. You can send nil to callback if you’d prefer not to handle it.
  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a \code
  [String: AnyObject]
  \endcode object. Former will not be nil when there’s any error happening; later describes the result. Default value is nil.

*/
- (void)enablePushNotificationOnCompletion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;
/**
  Disable to stop receiving push notification. You can check current state in property \code
  pushEanbled
  \endcode. You can send nil to callback if you’d prefer not to handle it.
  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a \code
  [String: AnyObject]
  \endcode object. Former will not be nil when there’s any error happening; later describes the result. Default value is nil.

*/
- (void)disablePushNotificationOnCompletion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;
/**
  Leave the chat room.
  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a \code
  [String: AnyObject]
  \endcode object. Former will not be nil when there’s any error happening; later describes the result. Default value is nil.

*/
- (void)leaveOnCompletion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;
/**
  Kick one user out of the chat room.
  \param ofUserSerial Target user serial.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an \code
  NSError
  \endcode and a \code
  DUChat
  \endcode object. Former will not be nil when there’s any error happening; later will be the updated self.

*/
- (void)kickUserOfUserSerial:(NSString * _Nonnull)serial onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;
/**
  When you receive system message of <em>user.joined</em>, you may need to update the property \code
  members
  \endcode in your local \code
  DUChat
  \endcode instance.
  \param ofUserSerial user serial which you’d like to add.

*/
- (void)addMemberOfUserSerial:(NSString * _Nonnull)serial;
/**
  When you receive system message of <em>user.kicked</em> or <em>user.left</em>, you may need to update the property \code
  members
  \endcode in your local \code
  DUChat
  \endcode instance.
  \param ofUserSerial user serial which you’d like to remove.

*/
- (void)removeMemberOfUserSerial:(NSString * _Nonnull)serial;
/**
  List <em>last 20</em> historical messages before the time you give.
  important:

  You should maintain your local time correctly synchronized; otherwise, you may not get your expected results.
  \param before Server will return you message before this time. Default value is the moment you call the function (\code
  NSDate()
  \endcode).

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an \code
  NSError
  \endcode and a \code
  [DUMessage]
  \endcode object. Former will not be nil when there’s any error happening; later will be historical messages.

*/
- (void)listMessagesBefore:(NSDate * _Nonnull)date onCompletion:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUMessage *> * _Nullable))completion;
/**
  List historical messages before the time you give. You can set the number of messages in a page and which page to return.
  important:

  You should maintain your local time correctly synchronized; otherwise, you may not get your expected results.
  \param before Server will return you message before this time. Default value is the moment you call the function (\code
  NSDate()
  \endcode).

  \param atPage To indicate which page to return.

  \param withCount Number of messages in a page.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an \code
  NSError
  \endcode and a \code
  [DUMessage]
  \endcode object. Former will not be nil when there’s any error happening; later will be historical messages.

*/
- (void)listMessagesBefore:(NSDate * _Nonnull)date atPage:(NSInteger)page withCount:(NSInteger)count onCompletion:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUMessage *> * _Nullable))completion;
/**
  Makr all messages before given time as read in this chat room.
  \param before All messages before this time will be marked as read.

  \param onCompletion Completion handler, default is \code
  nil
  \endcode.

*/
- (void)markAllAsReadBefore:(NSDate * _Nonnull)date onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  Send typing indicator of current user.
  \param ofType Typing indicator type.

*/
- (void)sendTypingIndicatorOfType:(enum DUTypingIndicator)type;
/**
  Sending a text message to all other users in this chat room.
  <h2>Example</h2>
  \code
  someChat.sendText(text: "Let's dinner @ Mircrosoft",
      wihtMeta: ["event":"https://www.facebook.com/events/123130617869478"],
      pushMessage: "Dinner Invitation")

  \endcodeimportant:

  If your push notification is well set, your text message will be sent along with a piece of push notification. The content of the notification will be the same as your text message. You can customize your content of the notification if you want.
  seealso:
  \code
  sendImage
  \endcode, \code
  sendFileAtPath
  \endcode and \code
  sendCustomMessage
  \endcode
  \param text Your message content.

  \param withMeta (Optional) Any extra information of this message.

  \param pushMessage (Optional) Customize content of push notification.

  \param pushPayload (Optional) Extra infromation in your push notification.

  \param badge (Optional) Badge number of push notification; default is “increment”, which adds your current badge number by 1, if you correctly set your number on Diuit API server.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
- (void)sendText:(NSString * _Nonnull)text withMeta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  Sending an image message to all other users in this chat room.
  important:

  Your image message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that your file can not be larger than 5 MB.
  seealso:
  \code
  sendText
  \endcode, \code
  sendFileAtPath
  \endcode and \code
  sendCustomMessage
  \endcode, \code
  DUMIMEType
  \endcode
  \param image Your image.

  \param withMime MIME type string based on your image file extension. We provide \code
  DUMIMEType
  \endcode for all image extensions supported by UIImage. Default value would be JPEG (Swift only).

  \param meta (Optional) Any extra information of this message.

  \param pushMessage (Optional) Customize content of push notification. Set this value to trigger push notification

  \param pushPayload (Optional) Extra infromation in your push notification.

  \param badge (Optional) Badge number of push notification; default is “increment”, which adds your current badge number by 1, if you correctly set your number on Diuit API server.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
- (void)sendImage:(UIImage * _Nonnull)image withMime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  Sending a file as message to all other users in this chat room.
  important:

  Your fle message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that your file can not be larger than 5 MB.
  seealso:
  \code
  sendText
  \endcode, \code
  sendImage
  \endcode and \code
  sendCustomMessage
  \endcode
  \param atPath The file path.

  \param withMime (Optional) Mime type of the file message. Default is \code
  application/octet-stream
  \endcode (general mime type)

  \param meta (Optional) Any extra information of this message.

  \param pushMessage (Optional) Customize content of push notification. Set this value to trigger push notification.

  \param pushPayload (Optional) Extra infromation in your push notification.

  \param badge (Optional) Badge number of push notification; default is “increment”, which adds your current badge number by 1, if you correctly set your number on Diuit API server.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
- (void)sendFileAtPath:(NSString * _Nonnull)path withMime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  Sending a custom message to all other users in this chat room.
  <h2>Example</h2>
  \code
  DUMessaging.sendCustomMessage(data: "Customized message",
      withMime:"application/my-custom-mime",
      pushMessage: "You've got a custom message",
      beforeSend: nil) { error, message in
          guard error == nil else {
              // Handle error
              return
          }
          print("new message #\(message!.id) sent")
      }

  \endcodeimportant:

  Your custom message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that the length of your message content can not be longer than 5 MB.
  seealso:
  \code
  sendText
  \endcode, \code
  sendImage
  \endcode and \code
  sendCustomMessage
  \endcode
  \param data Content of your custom message.

  \param withMime MIME type of the message. Follow the <a href="http://download.diuit.com/mime-types.json">standard here</a>.

  \param meta (Optional) Any extra information of this message.

  \param pushMessage (Optional) Customize content of push notification. Set this value to trigger push notification.

  \param pushPayload (Optional) Extra infromation in your push notification.

  \param badge (Optional) Badge number of push notification; default is “increment”, which adds your current badge number by 1, if you correctly set your number on Diuit API server.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
- (void)sendCustomMessage:(NSString * _Nonnull)data withMime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  Sending a text message with meta data to all other users in this chat room.
  important:

  If your push notification is well set, your text message will be sent along with a piece of push notification. The content of the notification will be the same as your text message. You can customize your content of the notification if you want.
  seealso:
  \code
  sendImage
  \endcode, \code
  sendFileAtPath
  \endcode and \code
  sendCustomMessage
  \endcode
  \param text Your message content.

  \param withMeta Any extra information of this message.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
- (void)sendText:(NSString * _Nonnull)text withMeta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  Sending an image message with meta data to all other users in this chat room.
  important:

  Sending image via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that your file can not be larger than 5 MB.
  seealso:
  \code
  sendText
  \endcode, \code
  sendFileAtPath
  \endcode and \code
  sendCustomMessage
  \endcode
  \param image Your image.

  \param withMime MIME type string based on your image file extension. We provide \code
  DUMIMEType
  \endcode for all image extensions supported by UIImage. Default value would be JPEG (Swift only).

  \param meta (Optional) Any extra information of this message.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
- (void)sendImage:(UIImage * _Nonnull)image withMime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  Sending a file as message to all other users in this chat room.
  important:

  Sending file via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that your file can not be larger than 5 MB.
  seealso:
  \code
  sendText
  \endcode, \code
  sendImage
  \endcode and \code
  sendCustomMessage
  \endcode
  \param atPath The file path.

  \param withMime Custom MIME type, default is \code
  application/octet-stream
  \endcode (general mime)

  \param meta (Optional) Any extra information of this message.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
- (void)sendFileAtPath:(NSString * _Nonnull)path withMime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  Sending a custom message to all other users in this chat room.
  important:

  Sending custom message via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that the length of your message content can not be longer than 5 MB.
  seealso:
  \code
  sendText
  \endcode, \code
  sendImage
  \endcode and \code
  sendCustomMessage
  \endcode
  \param data Content of your custom message.

  \param withMime MIME type of the message. Follow the <a href="http://download.diuit.com/mime-types.json">standard here</a>.

  \param meta (Optional) Any extra information of this message.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
- (void)sendCustomMessage:(NSString * _Nonnull)data withMime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

/**
  Type of chat rooms.
  <ul>
    <li>
      direct: Chat room for one-to-one message, only allow two members.
    </li>
    <li>
      group: General chat room. Members can operate join, leave or kick.
    </li>
  </ul>
*/
typedef SWIFT_ENUM(NSInteger, DUChatType) {
  DUChatTypeDirect = 0,
  DUChatTypeGroup = 1,
};

enum DUDevicePlatform : NSInteger;

/**
  Class for device in Diuit API.
*/
SWIFT_CLASS("_TtC11DUMessaging8DUDevice")
@interface DUDevice : NSObject
/**
  Device id.
*/
@property (nonatomic, readonly) NSInteger id;
/**
  Device serial.
*/
@property (nonatomic, readonly, copy) NSString * _Null_unspecified serial;
/**
  Any extra information of this device.
*/
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;
/**
  Platform type of this device.
  seealso:
  \code
  DUDevicePlatform
  \endcode
*/
@property (nonatomic, readonly) enum DUDevicePlatform platform;
/**
  Push notification token of this device.
*/
@property (nonatomic, readonly, copy) NSString * _Nullable pushToken;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

/**
  Enum for device platform. You must set this value right to receive push notification correctly.
  <ul>
    <li>
      android:       Android.
    </li>
    <li>
      iOSSandbox:    Use this value if you are using sandbox certification of push notfication.
    </li>
    <li>
      iOSProduction: Use this value if you are using sandbox certification of push notfication.
    </li>
    <li>
      notDefined:    Others platform.
    </li>
  </ul>
*/
typedef SWIFT_ENUM(NSInteger, DUDevicePlatform) {
  DUDevicePlatformAndroid = 0,
  DUDevicePlatformIOSSandbox = 1,
  DUDevicePlatformIOSProduction = 2,
  DUDevicePlatformNotDefined = 3,
};

/**
  Encoding schema of messages
  <ul>
    <li>
      utf8: UTF8 encoding, for plain text, custom message.
    </li>
    <li>
      base64: BASE64 encoding, for files or images (deprecated).
    </li>
    <li>
      binary: Binary encoding, for files or images.
    </li>
    <li>
      json: JSON encoding, this is used by system message.
    </li>
  </ul>
*/
typedef SWIFT_ENUM(NSInteger, DUEncoding) {
/**
  UTF8 encoding, for plain text.
*/
  DUEncodingUtf8 = 0,
/**
  BASE64 encoding, for files or images (deprecated).
*/
  DUEncodingBase64 = 1,
/**
  Binary encoding, for files or images.
*/
  DUEncodingBinary = 2,
/**
  JSON encoding, this is used by system message.
*/
  DUEncodingJson = 3,
};

enum DUMessageStatus : NSInteger;
@class DUUser;

/**
  Class for messages in Diuit API.
*/
SWIFT_CLASS("_TtC11DUMessaging9DUMessage")
@interface DUMessage : NSObject
/**
  Message id.
*/
@property (nonatomic, readonly) NSInteger id;
/**
  Mesage mime type. Follow the <a href="http://download.diuit.com/mime-types.json">standard here</a>. A system message’s mime is \code
  "application/diuit-chat-sys-message"
  \endcode
*/
@property (nonatomic, readonly, copy) NSString * _Nullable mime;
/**
  Encoding type, such as \code
  binary
  \endcode or \code
  utf8
  \endcode.
*/
@property (nonatomic, readonly, copy) NSString * _Nullable encoding;
/**
  Message content.
*/
@property (nonatomic, readonly, copy) NSString * _Nullable data;
/**
  Message created time.
*/
@property (nonatomic, readonly, copy) NSDate * _Nullable createdAt;
/**
  Message status of delivering, or receiving.
*/
@property (nonatomic, readonly) enum DUMessageStatus status;
/**
  The \code
  DUChat
  \endcode object that this message belongs to.
*/
@property (nonatomic, readonly, strong) DUChat * _Nullable chat;
/**
  The user who sends the message. If this message is a system message, snderUser will be \code
  nil
  \endcode.
*/
@property (nonatomic, readonly, strong) DUUser * _Nullable senderUser;
/**
  Any extra information of this message.
*/
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;
/**
  User serials of users who have read this message.
*/
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable reads;
/**
  For outgoing file and video messges, this property indicates the local path of media resource.
*/
@property (nonatomic, copy) NSString * _Nullable localMediaPath;
/**
  For outgoing image message, this property holds the source \code
  UIImage
  \endcode object.
*/
@property (nonatomic, strong) UIImage * _Nullable localImage;
/**
  Mark a message as read status. The ‘reads’ property will be automatically update once the task completes successfully.
  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will the self.

*/
- (void)markAsReadOnCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

/**
  This enum indicates the delivery/receiving status of a message.
  <ul>
    <li>
      notDelivered: The message object is created but not sent out yet.
    </li>
    <li>
      delivered:    The message is delivered.
    </li>
    <li>
      failedToSend: The message failed to be sent.
    </li>
    <li>
      received:     This message is an incoming message.
    </li>
  </ul>
*/
typedef SWIFT_ENUM(NSInteger, DUMessageStatus) {
  DUMessageStatusNotDelivered = 0,
  DUMessageStatusDelivered = 1,
  DUMessageStatusFailedToSend = 2,
  DUMessageStatusReceived = 3,
};

enum DUOrder : NSInteger;

/**
  Diuit Message API client class, provides different static methods to help you manage instances of DUChat, send direct messages and retrieve list of DUAnnounce. Most methods are static
*/
SWIFT_CLASS("_TtC11DUMessaging11DUMessaging")
@interface DUMessaging : NSObject
/**
  Current logged in user, which is an instance of \code
  DUUser
  \endcode.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) DUUser * _Nullable currentUser;)
+ (DUUser * _Nullable)currentUser;
/**
  Current logged in device, which is an instance of \code
  DUDevice
  \endcode.
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) DUDevice * _Nullable currentDevice;)
+ (DUDevice * _Nullable)currentDevice;
/**
  Status of connection
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isConnected;)
+ (BOOL)isConnected;
/**
  App ID of your application. If you don’t have one, please check https://developer.diuit.com/appkeys
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Null_unspecified appId;)
+ (NSString * _Null_unspecified)appId;
/**
  App Key of your application. If you don’t have one, please check https://developer.diuit.com/appkeys
*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Null_unspecified appKey;)
+ (NSString * _Null_unspecified)appKey;
/**
  Set your App Id and App Key.
  <h2>Example</h2>
  \code
  DUMessaging.set(appId: "yourAppId", appKey: "yourAppKey")

  \endcodeimportant:

  This is the first method you should call. It’s supposed to be set in your AppDelegate.swift of AppDelegate.m
  \param appId App Id of your application. You can get it from <a href="https://developer.diuit.com/appkeys">Diuit API Dashboard</a>

  \param appKey App Key of your application. You can get it from <a href="https://developer.diuit.com/appkeys">Diuit API Dashboard</a>

*/
+ (void)setWithAppId:(NSString * _Nonnull)appId appKey:(NSString * _Nonnull)appKey;
/**
  Auth your device with the session token retrieved from Diuit API server. Because we do not own your credential, you have to let your server authenticate device’s identity. Then your server do an extra authentication with Diuit API server. Finally, pass the resulting session token (which will be a string like “1f4e5e4f01736f6d07a9db252ad4e90f”) back to the device and send to this method. For example, your server may have a signin API. When this API is called by some device from APP and passed the authentication. Your server then should do second authentication with Diuit API server and a session token will be returned. In the end, you can wrap this session token in your login API response and device is able to receive it. If you have any difficulties in retrieving session tokens, please check <a href="http://api.diuit.com/doc/en/guideline.html">development guide</a> for assistance.
  <h2>Example</h2>
  \code
  DUMessaging.auth(withSessionToken: "my_token") { error, result in
      guard error == nil else {
          // Handle error
          return
      }
      // Do something here
      print("My user serial is : \(DUMessaging.currentUser!.serial)")
  }

  \endcodeimportant:

  It’s highly recommended to retrieve the session token in your server instead of doing it in APP. We DO NO OWN your credentail, so you must authenticate the identity from each device on your server.
  \param withSessionToken The session token retrieved from Diuit API server.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and [String: AnyObject] Dictionary. Former will not be nil when there’s any error happening; later will describe the information of device and user from Diuit API server’s database.

*/
+ (void)authWithSessionToken:(NSString * _Nonnull)token onCompletion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;
/**
  Update your push token on Diuit API server from device. This must be done when you’d like to receive push notification. You can do it whether you are logged in or not. If you have not logged in, this information will be cached and updated right after you log in.
  <h2>Example</h2>
  \code
  func application(_ application: UIApplication!, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: NSData! ) {

      let characterSet: NSCharacterSet = NSCharacterSet( charactersInString: "<>" )

      let deviceTokenString: String = ( deviceToken.description as NSString )
          .stringByTrimmingCharactersInSet( characterSet )
          .stringByReplacingOccurrencesOfString( " ", withString: "" ) as String

      DUMessaging.updatePushToken(with: deviceTokenString) { error, result in
          guard error == nil else {
              // Handle error
              return
          }
          print(result["message"])
      }

  }

  \endcode\param with Device’s push token in String

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and [String: AnyObject] Dictionary. Former will not be nil when there’s any error happening; later will be a message of updating results.

*/
+ (void)updatePushTokenWith:(NSString * _Nonnull)token onCompletion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;
/**
  Update your push token on Diuit API server from device. This must be done when you’d like to receive push notification. You can do it whether you are logged in or not. If you have not logged in, this information will be cached and updated right after you log in.
  <h2>Example</h2>
  \code
  func application(_ application: UIApplication!, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: NSData! ) {
     DUMessaging.updatePushToken(from: deviceToken!) { error, result in
         guard error == nil else {
             // Handle error
             return
         }
         print(result["message"])
     }
  }

  \endcode\param from Device’s push token in NSData, the original data type you get in AppDelegate

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and [String: AnyObject] Dictionary. Former will not be nil when there’s any error happening; later will be a message of updating results.

*/
+ (void)updatePushTokenFrom:(NSData * _Nonnull)tokenData onCompletion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;
/**
  Sychronize your badge number at local side with the server side. After your reduce your badge number due to reasons such as messages being read, you must sync your new badge number with Diuit API server. You can customize your push notification sent by Diuit API server and also the badge number. “increment” will make your badge number increment as long as your local badge number is identical to the server’s.
  This method also works when you have not logged in, the badge number will be updated right after you log in.
  <h2>Example</h2>
  \code
  // Assume that your badge number is 5, and two unread messages just got marked as read.
  // Therefore your badge decreases to 3.
  DUMessaging.updateBadge(with: 3, onCompletion: nil)

  \endcode\param with The badge number.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and [String: AnyObject] Dictionary. Former will not be nil when there’s any error happening; later will be a message of updating results.

*/
+ (void)updateBadgeWith:(NSInteger)badge onCompletion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;
/**
  This method creates a new group chat room (<em>DUChat</em>) with given user serials, meta and white list.
  <h2>Example</h2>
  \code
  // You are "user.0"
  DUMessaging.createChatRoom(withMembers: ["user.1", "user.2"], meta: ["name": "Party All Night!"], whiteList: ["user.0", "user.1", "user.2"]) { error, chat in
      guard error == nil else {
          // Handle error
          return
      }
      print("Your new chat id is \(chat!.id)")
  }

  \endcodeseealso:
  \code
  createDirectChatWith
  \endcode, method to create a direct chat room
  \param withMembers User serials of the users you’d like to be grouped with. <em>DO NOT</em> add your user serial in this array.

  \param meta (Optional) Any extra information of this chat room, such as a name. It accepts all kinds of data as long as it’s a [String: AnyObject] Dictionary.

  \param whiteList User can only join this chat room as long as his user serial exists in this list. Set to nil to allow every one to join.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUChat instance. Former will not be nil when there’s any error happening; later will be the instance of newly created chat room.

*/
+ (void)createChatRoomWithMembers:(NSArray<NSString *> * _Nonnull)members meta:(NSDictionary<NSString *, id> * _Nullable)meta whiteList:(NSArray<NSString *> * _Nullable)whiteList onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;
/**
  Join any chat room with its id as long as you are allowed to. You will recevie a permission-denied error if you are not on the white list of the chat room.
  <h2>Example</h2>
  \code
  DUMessaging.joinChatRoom(ofId:999) { error, chat in
      guard error == nil else {
          // Handle error
          return
      }
      print("You've just joined room #\(chat!.id)")
  }

  \endcodeimportant:

  You can not operate this function in a <em>direct message chat room</em>. If you do so, you will receive a operation-not-supported error (480).
  \param ofId The id of the chat room.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUChat instance. Former will not be nil when there’s any error happening; later will be the instance of the chat room.

*/
+ (void)joinChatRoomOfId:(NSInteger)chatId onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;
/**
  List all your chatrooms, including group chat rooms and direct chat rooms.
  <h2>Example</h2>
  \code
  DUMessaging.listAllChatRooms() { error, chats in
      guard error == nil else {
          // Handle error
          return
      }
      print("I have \(chats!.count) chat rooms")
  }

  \endcode\param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and an Array of DUChat. Former will not be nil when there’s any error happening; later will be an Array of DUChat which you are in.

*/
+ (void)listAllChatRoomsOnCompletion:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUChat *> * _Nullable))completion;
/**
  List all your direct chat rooms <em>or</em> group chat rooms corresponding to given argument.
  <h2>Example</h2>
  \code
  DUMessaging.listChatRooms(ofType: .group) { error, chats in
      guard error == nil else {
          // Handle error
          return
      }
      print("I have \(chats!.count) group chat rooms.")
  }

  \endcode\param ofType Either direct chat room or group chat room.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and an Array of DUChat. Former will not be nil when there’s any error happening; later will be an Array of DUChat which you are in.

*/
+ (void)listChatRoomsOfType:(enum DUChatType)type onCompletion:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUChat *> * _Nullable))completion;
/**
  You can get a single chat room detail by querying with chat room id
  \param ofId The id of the chat room that you want to look up with

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and an instance of DUChat. Former will not be nil when there’s any error happening; later will be the result that you want.

*/
+ (void)getChatRoomDetailOfId:(NSInteger)chatId onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;
/**
  This method creates a new direct chat room (<em>DUChat</em>) with given member and meta. Direct chat does not support kick, join, leave and update white list. This is a special chat room with only two members, aiming for one-to-one communication.
  <h2>Example</h2>
  \code
  DUMessaging.createDirectChatRoom(withUserSerial: "myFriend", meta:["foo": "bar" as AnyObject]) { error, chat in
      guard error == nil else {
          // Handle error
          return
      }
      // Send your direct messages
  }

  \endcodeseealso:
  \code
  createChatWith
  \endcode, method to create a group chat room
  \param withUserSerial Target user serial

  \param meta (Optional) Any extra information of this chat room, such as a name. It accepts all kinds of data as long as it’s a [String: AnyObject] Dictionary.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUChat instance. Former will not be nil when there’s any error happening; later will be the instance of newly created chat room.

*/
+ (void)createDirectChatRoomWithUserSerial:(NSString * _Nonnull)serial meta:(NSDictionary<NSString *, id> * _Nullable)meta onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;
/**
  You can block some user to refuse any direct message exchanging between you two. Note that you still can talk to this user in other group chat rooms.
  seealso:
  \code
  unblockUser
  \endcode, to unblock user.
  \param ofSerial User serial of the target user.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a nil object. Former will not be nil when there’s any error happening; later will always be nil.

*/
+ (void)blockUserOfSerial:(NSString * _Nonnull)serial onCompletion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;
/**
  You can unblock some user to restart direct message exchanging between you two.
  seealso:
  \code
  blockUser
  \endcode, method to block user.
  \param ofSerial User serial of the target user.

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a nil object. Former will not be nil when there’s any error happening; later will always be nil.

*/
+ (void)unblockUserOfSerial:(NSString * _Nonnull)serial onCompletion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;
/**
  You can directly send a direct (one-to-one) text message to target user via this function. You will receive an error of permission denied as long as you are blocked.
  <h2>Example</h2>
  \code
  DUMessaging.sendDirectText(toUserSerial: "myFriend1",
     withText: "Let's dinner @ Mircrosoft",
     meta: ["event":"https://www.facebook.com/events/123130617869478" as AnyObject],
     pushMessage: "Dinner Invitation",
     beforeSend: { message in
         // deal with the message before sending out ( sucah as refresh UI)
     }) { error, message in
         // message is delivered and updated with server-side information, such as id, createdAt and etc..
     }

  \endcodeimportant:

  If your push notification is well set, your text message will be sent along with a piece of push notification. The content of the notification will be the same as your text message. You can customize your content of the notification if you want.
  seealso:
  \code
  sendDirectImage
  \endcode, \code
  snedDirectFile
  \endcode and \code
  sendDirectCustomMessage
  \endcode
  \param toUserSerial User serial of the target user.

  \param withText Your message content.

  \param meta (Optional) Any extra information of this message.

  \param pushMessage (Optional) Customize content of push notification.

  \param pushPayload (Optional) Extra infromation in your push notification.

  \param badge (Optional) Badge number of push notification; default is “increment”, which adds your current badge number by 1, if you correctly set your number on Diuit API server.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
+ (void)sendDirectTextToUserSerial:(NSString * _Nonnull)serial withText:(NSString * _Nonnull)text meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  You can directly send a direct (one-to-one) image message to target user via this function. You will receive an error of permission denied as long as you are blocked.
  <h2>Example</h2>
  \code
  let targetImage = UIImage(named:"sexy.jpg")
  DUMessaging.sendDirectImage(toUserSerial: "myFriend2",
      withImage: targetImage,
      pushMessage: "You've to an image message",
      beforeSend: { message in
         // deal with the message before sending out ( sucah as refresh UI)
      }) { error, message in
         // message is delivered and updated with server-side information, such as id, createdAt and etc..
      }

  \endcodeimportant:

  Your image message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that your file can not be larger than 5 MB.
  seealso:
  \code
  sendDirectText
  \endcode, \code
  snedDirectFile
  \endcode and \code
  sendDirectCustomMessage
  \endcode
  \param serial User serial of the target user.

  \param image Your image.

  \param mime MIME type string based on your image file extension. We provide \code
  DUMIMEType
  \endcode for all image extensions supported by UIImage.

  \param meta (Optional) Any extra information of this message.

  \param pushMessage (Optional) Customize content of push notification.

  \param pushPayload (Optional) Extra infromation in your push notification.

  \param badge (Optional) Badge number of push notification; default is “increment”, which adds your current badge number by 1, if you correctly set your number on Diuit API server.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
+ (void)sendDirectImageToUserSerial:(NSString * _Nonnull)serial withImage:(UIImage * _Nonnull)image mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  You can directly send a direct (one-to-one) file message to target user via this function. You will receive an error of permission denied as long as you are blocked.
  <h2>Example</h2>
  \code
  let filePath = NSTemporaryDirectory() + "example.pdf"
  DUMessaging.sendDirectFile(toUserSerial: "myFriend3",
     atPath: filePath,
     meta: ["name":"example.pdf"],
     pushMessage: "You've got a pdf"),
     beforeSend: { message in
         // deal with the message before sending out ( sucah as refresh UI)
     }) { error, message in
         // message is delivered and updated with server-side information, such as id, createdAt and etc..
     }

  \endcodeimportant:

  Your file message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that your file can not be larger than 5 MB.
  seealso:
  \code
  sendDirectText
  \endcode, \code
  snedDirectImage
  \endcode and \code
  sendDirectCustomMessage
  \endcode
  \param toUserSerial User serial of the target user.

  \param atPath Your file path.

  \param withMime (Optional) Mime type of the file, defualt is \code
  application/octet-stream
  \endcode (general file)

  \param meta (Optional) Any extra information of this message. You can pass the file name here.

  \param pushMessage (Optional) Customize content of push notification.

  \param pushPayload (Optional) Extra infromation in your push notification.

  \param badge (Optional) Badge number of push notification; default is “increment”, which adds your current badge number by 1, if you correctly set your number on Diuit API server.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
+ (void)sendDirectFileToUserSerial:(NSString * _Nonnull)serial atPath:(NSString * _Nonnull)path withMime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  You can directly send a direct (one-to-one) custom message to target user via this function. You will receive an error of permission denied as long as you are blocked.
  <h2>Example</h2>
  \code
  DUMessaging.sendDirectCustomMessage("Customized message",
     toUserSerial: "myFriend4",
     withMime:"application/my-mime",
     pushMessage: "You've got a custom message"),
     beforeSend: { message in
         // deal with the message before sending out ( sucah as refresh UI)
     }) { error, message in
         // message is delivered and updated with server-side information, such as id, createdAt and etc..
     }

  \endcodeimportant:

  Your custom message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that your message size can not be larger than 5 MB.
  seealso:
  \code
  sendDirectText
  \endcode, \code
  snedDirectImage
  \endcode and \code
  sendDirectFile
  \endcode
  \param data Your message content.

  \param toUserSerial User serial of the target user.

  \param withMime Your message mime type. It’s hight recommened that you follow <a href="http://download.diuit.com/mime-types.json">the standard</a>.

  \param meta (Optional) Any extra information of this message. You can pass the file name here.

  \param pushMessage (Optional) Customize content of push notification.

  \param pushPayload (Optional) Extra infromation in your push notification.

  \param badge (Optional) Badge number of push notification; default is “increment”, which adds your current badge number by 1, if you correctly set your number on Diuit API server.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
+ (void)sendDirectCustomMessage:(NSString * _Nonnull)data toUserSerial:(NSString * _Nonnull)serial withMime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  You can directly send a direct (one-to-one) text message to target user via this function. You will receive an error of permission denied as long as you are blocked.
  important:

  If your push notification is well set, your text message will be sent along with a piece of push notification. The content of the notification will be the same as your text message. You can customize your content of the notification if you want.
  seealso:
  \code
  sendDirectImage
  \endcode, \code
  snedDirectFile
  \endcode and \code
  sendDirectCustomMessage
  \endcode
  \param toUserSerial User serial of the target user.

  \param withText Your message content.

  \param meta Any extra information of this message.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
+ (void)sendDirectTextToUserSerial:(NSString * _Nonnull)serial withText:(NSString * _Nonnull)text meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  You can directly send a direct (one-to-one) image message to target user via this function. You will receive an error of permission denied as long as you are blocked.
  important:

  Sending image via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that your file can not be larger than 5 MB.
  seealso:
  \code
  sendDirectText
  \endcode, \code
  snedDirectFile
  \endcode and \code
  sendDirectCustomMessage
  \endcode
  \param toUserSerial User serial of the target user.

  \param withImage Your image.

  \param mime MIME type string based on your image file extension. We provide \code
  DUMIMEType
  \endcode for all image extensions supported by UIImage. Default value would be JPEG (Swift only).

  \param meta Any extra information of this message.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
+ (void)sendDirectImageToUserSerial:(NSString * _Nonnull)serial withImage:(UIImage * _Nonnull)image mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  Directly send a file as direct (one-to-one) message to target user via this function. In this function, the MIME type will be set to \code
  application/octet-stream
  \endcode in default, you can also use your customize value. You will receive an error of permission denied as long as you are blocked.
  important:

  Sending file via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that your file can not be larger than 5 MB.
  seealso:
  \code
  sendDirectText
  \endcode, \code
  snedDirectImage
  \endcode and \code
  sendDirectCustomMessage
  \endcode
  \param toUserSerial User serial of the target user.

  \param atPath Your file path.

  \param withMime Mime type of the file, defualt is \code
  application/octet-stream
  \endcode (general file)

  \param meta Any extra information of this message. You can pass the file name here.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
+ (void)sendDirectFileToUserSerial:(NSString * _Nonnull)serial atPath:(NSString * _Nonnull)path withMime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  You can directly send a direct (one-to-one) custom message to target user via this function. You will receive an error of permission denied as long as you are blocked.
  important:

  Sending file via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that your data length can not be longer than 5 MB.
  seealso:
  \code
  sendDirectText
  \endcode, \code
  snedDirectImage
  \endcode and \code
  sendDirectFile
  \endcode
  \param data Your message content.

  \param toUserSerial User serial of the target user.

  \param withMime Your message mime type. It’s hight recommened that you follow <a href="http://download.diuit.com/mime-types.json">the standard</a>.

  \param meta Any extra information of this message. You can pass the file name here.

  \param beforeSend Before message sends out, you will get a \code
  DUMessage
  \endcode object

  \param onCompletion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there’s any error happening; later will an instance of DUMessage, your newly created message.

*/
+ (void)sendDirectCustomMessage:(NSString * _Nonnull)data toUserSerial:(NSString * _Nonnull)serial withMime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
/**
  This function helps your retrieve <em>last 20</em> announcements. You can set keywords as query condition. The result can be listed by creadted or updated time in ascending or descending order based on the enum (DUOrder) you give.
  Announcements can only be created, updated or deleted from the server side.
  \param keywords Keywords for querying announcements. Set to nil if you want to list all announcements

  \param orderBy Rules of list order.

  \param completion completion: The closure object to be executed when the task finishes successfully. It will return an NSError and a [DUAnnounce] object. Former will not be nil when there’s any error happening; later will an Array of DUAnnounce, your query result.

*/
+ (void)listAnnouncesWithKeywords:(NSString * _Nullable)keywords orderBy:(enum DUOrder)orderBy onCompletion:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUAnnounce *> * _Nullable))completion;
/**
  This function helps your retrieve announcements. You can set keywords as query condition, count for how many announcements in a pgae, and page to indicate which page of announcements to return based on your count number. The result can be listed by creadted or updated time in ascending or descending order based on the enum (DUOrder) you give.
  Announcements can only be created, updated or deleted from the server side.
  \param withKeywords Keywords for querying announcements. Set to nil if you want to list all announcements

  \param page Page number of announcements to return, starting form 0.

  \param count Number of announcements in a page. Value 20 is recommended.

  \param orderBy Rules of list order.

  \param onCompletion completion: The closure object to be executed when the task finishes successfully. It will return an NSError and a [DUAnnounce] object. Former will not be nil when there’s any error happening; later will an Array of DUAnnounce, your query result.

*/
+ (void)listAnnouncesWithKeywords:(NSString * _Nullable)keywords page:(NSInteger)page count:(NSInteger)count orderBy:(enum DUOrder)orderBy onCompletion:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUAnnounce *> * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/**
  Order types of announcements list.
  <ul>
    <li>
      createdDescending: Order by create time, descneding.
    </li>
    <li>
      createdAscending: Order by create time, ascneding.
    </li>
    <li>
      updatedDescending: Order by update time, descneding.
    </li>
    <li>
      updatedAscending: Order by update time, ascneding.
    </li>
  </ul>
*/
typedef SWIFT_ENUM(NSInteger, DUOrder) {
  DUOrderCreatedDescending = 0,
  DUOrderCreatedAscending = 1,
  DUOrderUpdatedDescending = 2,
  DUOrderUpdatedAscending = 3,
};

/**
  Status of typing indicator
  <ul>
    <li>
      isTyping: user is typing
    </li>
  </ul>
*/
typedef SWIFT_ENUM(NSInteger, DUTypingIndicator) {
  DUTypingIndicatorIsTyping = 0,
};


/**
  Class for user in Diuit API.
*/
SWIFT_CLASS("_TtC11DUMessaging6DUUser")
@interface DUUser : NSObject
/**
  User id.
*/
@property (nonatomic, readonly) NSInteger id;
/**
  User serial.
*/
@property (nonatomic, readonly, copy) NSString * _Null_unspecified serial;
/**
  Any extra information of this user.
*/
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;
/**
  User serials of blocked users.
*/
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable blackList;
/**
  Update user meta.
  \param meta Dictionary object you want to saved in user meta.

  \param onCompletion Completion handler for updating meta.

*/
- (void)updateWithMeta:(NSDictionary<NSString *, id> * _Nonnull)meta onCompletion:(void (^ _Nullable)(NSError * _Nullable, DUUser * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


@interface SocketIOClient (SWIFT_EXTENSION(DUMessaging))
@end


@interface UIImage (SWIFT_EXTENSION(DUMessaging))
@end

#pragma clang diagnostic pop

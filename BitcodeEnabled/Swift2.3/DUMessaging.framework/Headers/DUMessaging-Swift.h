// Generated by Apple Swift version 2.3 (swiftlang-800.10.12 clang-800.0.38)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import SocketIO;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class NSDate;
@class DUChannel;


/// Class for announcement in Diuit API. In APP, you can only list announcements. Creat, update and delete announce must be operated on server side.
SWIFT_CLASS("_TtC11DUMessaging10DUAnnounce")
@interface DUAnnounce : NSObject

/// Announcement id.
@property (nonatomic, readonly) NSInteger id;

/// Type of announcement.
@property (nonatomic, readonly, copy) NSString * _Nullable title;

/// The keywords used for querying announcements.
@property (nonatomic, readonly, copy) NSString * _Nullable type;

/// The keywords used for querying announcements.
@property (nonatomic, readonly, copy) NSString * _Nullable keywords;

/// Content of announcement.
@property (nonatomic, readonly, copy) NSString * _Nullable body;

/// Any extra information of this announcement.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;

/// Creation time.
@property (nonatomic, readonly, strong) NSDate * _Nullable createdAt;

/// Last updated time
@property (nonatomic, readonly, strong) NSDate * _Nullable updatedAt;

/// The DUChannel object that this announcement belongs to. Always create a new instance here. Each announcement belongs to one channel.\See 
///
/// <code>DUChannel
/// </code>
@property (nonatomic, readonly, strong) DUChannel * _Nullable channel;

/// If this announcement comes with a push notification.
@property (nonatomic, readonly) BOOL hasNotification;
@end



/// Class for channel in Diuit API.
SWIFT_CLASS("_TtC11DUMessaging9DUChannel")
@interface DUChannel : NSObject

/// Channel id.
@property (nonatomic, readonly) NSInteger id;

/// Title of this channel.
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
@end

enum DUChatType : NSInteger;
@class DUMessage;
@class NSError;
enum DUTypingIndicator : NSInteger;
@class UIImage;


/// Class for chat rooms. You can list historical messages, manage properties and send messages via this class.
SWIFT_CLASS("_TtC11DUMessaging6DUChat")
@interface DUChat : NSObject

/// Id of the chat room.
@property (nonatomic, readonly) NSInteger id;

/// Indicates if this chat room is a direct or group chat room.
@property (nonatomic, readonly) enum DUChatType type;

/// Last message in this chat room.
@property (nonatomic, strong) DUMessage * _Nullable lastMessage;

/// User serials in this chat room.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable members;

/// User serials that are allowed to be in this chat room. Set to nil to allow everyone.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable whiteList;

/// Extra information of the chat room.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;

/// If you can receive push notification. Use enablePushNotification or disablePushNotification to enable or disable.
@property (nonatomic, readonly) BOOL pushEnabled;

/// This property is only for direct chat rooms to indicate if you block another user. In a group chat room, this value will always be false.
@property (nonatomic, readonly) BOOL isBlockedByMe;

/// Count of unread messages in this chat room.
@property (nonatomic, readonly) NSInteger unreadMessageCount;

/// Update meta of the chat room.
///
/// \param meta Any extra information of the chat room, such as name.
///
/// \param completion completion: The closure object to be executed when the task finishes successfully. It will return an <code>NSError
/// </code> and a <code>DUChat
/// </code> object. Former will not be nil when there's any error happening; later will be the updated self.
- (void)updateMeta:(NSDictionary<NSString *, id> * _Nullable)meta completion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;

/// Update white list of the chat room. Only users on the list can join this room. Set to nil if you'd like to allow all users.
///
/// \param whiteList User serials of allowed users.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an <code>NSError
/// </code> and a <code>DUChat
/// </code> object. Former will not be nil when there's any error happening; later will be the updated self.
- (void)updateWhiteList:(NSArray<NSString *> * _Nullable)whiteList completion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;

/// Enable to receive push notification. You can check current state in property pushEanbled. You can send nil to callback if you'd prefer not to handle it.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a <code>[String: AnyObject]
/// </code> object. Former will not be nil when there's any error happening; later describes the result. Default value is nil.
- (void)enablePushNotification:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;

/// Disable to stop receiving push notification. You can check current state in property pushEanbled. You can send nil to callback if you'd prefer not to handle it.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a <code>[String: AnyObject]
/// </code> object. Former will not be nil when there's any error happening; later describes the result. Default value is nil.
- (void)disablePushNotification:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;

/// Leave the chat room.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a <code>[String: AnyObject]
/// </code> object. Former will not be nil when there's any error happening; later describes the result. Default value is nil.
- (void)leaveOnCompletion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;

/// Kick one user out of the chat room.
///
/// \param userSerial Target user serial.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an <code>NSError
/// </code> and a <code>DUChat
/// </code> object. Former will not be nil when there's any error happening; later will be the updated self.
- (void)kickUser:(NSString * _Nonnull)userSerial completion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;

/// When you receive system message of user.joined, you may need to update the property members in your local DUChat instance.
///
/// \param serial user serial which you'd like to add.
- (void)addMemberWith:(NSString * _Nonnull)serial;

/// When you receive system message of user.kicked or user.left, you may need to update the property members in your local DUChat instance.
///
/// \param serial user serial which you'd like to remove.
- (void)removeMemberWith:(NSString * _Nonnull)serial;

/// List last 20 historical messages before the time you give.\Important 
///
/// 
/// You should maintain your local time correctly synchronized; otherwise, you may not get your expected results.
///
/// \param date Server will return you message before this time. Default value is the moment you call the function (<code>NSDate()
/// </code>).
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an <code>NSError
/// </code> and a <code>[DUMessage]
/// </code> object. Former will not be nil when there's any error happening; later will be historical messages.
- (void)listMessagesBefore:(NSDate * _Nonnull)date completion:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUMessage *> * _Nullable))completion;

/// List historical messages before the time you give. You can set the number of messages in a page and which page to return.\Important 
///
/// 
/// You should maintain your local time correctly synchronized; otherwise, you may not get your expected results.
///
/// \param date Server will return you message before this time. Default value is the moment you call the function (<code>NSDate()
/// </code>).
///
/// \param count Number of messages in a page.
///
/// \param page To indicate which page to return.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an <code>NSError
/// </code> and a <code>[DUMessage]
/// </code> object. Former will not be nil when there's any error happening; later will be historical messages.
- (void)listMessagesBefore:(NSDate * _Nonnull)date withCount:(NSInteger)count atPage:(NSInteger)page completion:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUMessage *> * _Nullable))completion;

/// Makr all messages before given time as read in this chat room.
///
/// \param before All messages before this time will be marked as read.
///
/// \param completion Completion handler, default is <code>nil
/// </code>.
- (void)markAllAsReadBefore:(NSDate * _Nonnull)before completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// Send typing indicator of current user.
///
/// \param ofType Typing indicator type.
- (void)sendTypingIndicator:(enum DUTypingIndicator)ofType;

/// Sending a text message to all other users in this chat room.
///
/// <h2>Example</h2>
/// <code>someChat.sendText(text: "Let's dinner @ Mircrosoft",
///     meta: ["event":"https://www.facebook.com/events/123130617869478"],
///     pushMessage: "Dinner Invitation")
/// 
/// </code>\Important 
/// 
/// If your push notification is well set, your text message will be sent along with a piece of push notification. The content of the notification will be the same as your text message. You can customize your content of the notification if you want.\See 
///
/// <code>sendImage
/// </code>, <code>sendFileAtPath
/// </code> and <code>sendCustomMessage
/// </code>
///
/// \param text Your message content.
///
/// \param meta (Optional) Any extra information of this message.
///
/// \param pushMessage (Optional) Customize content of push notification.
///
/// \param pushPayload (Optional) Extra infromation in your push notification.
///
/// \param badge (Optional) Badge number of push notification; default is "increment", which adds your current badge number by 1, if you correctly set your number on Diuit API server.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
- (void)sendText:(NSString * _Nonnull)text meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// Sending an image message to all other users in this chat room.\Important 
///
/// 
/// Your image message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that your file can not be larger than 5 MB.\See 
///
/// <code>sendText
/// </code>, <code>sendFileAtPath
/// </code> and <code>sendCustomMessage
/// </code>, <code>DUMIMEType
/// </code>
///
/// \param image Your image.
///
/// \param mime MIME type string based on your image file extension. We provide <code>DUMIMEType
/// </code> for all image extensions supported by UIImage. Default value would be JPEG (Swift only).
///
/// \param meta (Optional) Any extra information of this message.
///
/// \param pushMessage (Optional) Customize content of push notification. Set this value to trigger push notification
///
/// \param pushPayload (Optional) Extra infromation in your push notification.
///
/// \param badge (Optional) Badge number of push notification; default is "increment", which adds your current badge number by 1, if you correctly set your number on Diuit API server.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
- (void)sendImage:(UIImage * _Nonnull)image mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// Sending a file as message to all other users in this chat room.\Important 
///
/// 
/// Your fle message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that your file can not be larger than 5 MB.\See 
///
/// <code>sendText
/// </code>, <code>sendImage
/// </code> and <code>sendCustomMessage
/// </code>
///
/// \param path The file path.
///
/// \param meta (Optional) Any extra information of this message.
///
/// \param pushMessage (Optional) Customize content of push notification. Set this value to trigger push notification.
///
/// \param pushPayload (Optional) Extra infromation in your push notification.
///
/// \param badge (Optional) Badge number of push notification; default is "increment", which adds your current badge number by 1, if you correctly set your number on Diuit API server.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
- (void)sendFileAtPath:(NSString * _Nonnull)path mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// Sending a custom message to all other users in this chat room.
///
/// <h2>Example</h2>
/// <code>DUMessaging.sendCustomMessage(data: "Customized message",
///     mime:"application/my-custom-mime",
///     pushMessage: "You've got a custom message") { error, message in
///         guard error == nil else {
///             // Handle error
///             return
///         }
///         print("new message #\(message!.id) sent")
///     }
/// 
/// </code>\Important 
/// 
/// Your custom message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that the length of your message content can not be longer than 5 MB.\See 
///
/// <code>sendText
/// </code>, <code>sendImage
/// </code> and <code>sendCustomMessage
/// </code>
///
/// \param data Content of your custom message.
///
/// \param mime MIME type of the message. Follow the <a href="http://download.diuit.com/mime-types.json">standard here</a>.
///
/// \param meta (Optional) Any extra information of this message.
///
/// \param pushMessage (Optional) Customize content of push notification. Set this value to trigger push notification.
///
/// \param pushPayload (Optional) Extra infromation in your push notification.
///
/// \param badge (Optional) Badge number of push notification; default is "increment", which adds your current badge number by 1, if you correctly set your number on Diuit API server.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
- (void)sendCustomMessage:(NSString * _Nonnull)data mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// Sending a text message with meta data to all other users in this chat room.\Important 
///
/// 
/// If your push notification is well set, your text message will be sent along with a piece of push notification. The content of the notification will be the same as your text message. You can customize your content of the notification if you want.\See 
///
/// <code>sendImage
/// </code>, <code>sendFileAtPath
/// </code> and <code>sendCustomMessage
/// </code>
///
/// \param text Your message content.
///
/// \param meta Any extra information of this message.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
- (void)sendText:(NSString * _Nonnull)text meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// Sending an image message with meta data to all other users in this chat room.\Important 
///
/// 
/// Sending image via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that your file can not be larger than 5 MB.\See 
///
/// <code>sendText
/// </code>, <code>sendFileAtPath
/// </code> and <code>sendCustomMessage
/// </code>
///
/// \param image Your image.
///
/// \param mime MIME type string based on your image file extension. We provide <code>DUMIMEType
/// </code> for all image extensions supported by UIImage. Default value would be JPEG (Swift only).
///
/// \param meta (Optional) Any extra information of this message.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
- (void)sendImage:(UIImage * _Nonnull)image mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// Sending a file as message to all other users in this chat room.\Important 
///
/// 
/// Sending file via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that your file can not be larger than 5 MB.\See 
///
/// <code>sendText
/// </code>, <code>sendImage
/// </code> and <code>sendCustomMessage
/// </code>
///
/// \param path The file path.
///
/// \param mime Custom MIME type
///
/// \param meta (Optional) Any extra information of this message.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
- (void)sendFileAtPath:(NSString * _Nonnull)path mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// Sending a custom message to all other users in this chat room.\Important 
///
/// 
/// Sending custom message via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that the length of your message content can not be longer than 5 MB.\See 
///
/// <code>sendText
/// </code>, <code>sendImage
/// </code> and <code>sendCustomMessage
/// </code>
///
/// \param data Content of your custom message.
///
/// \param mime MIME type of the message. Follow the <a href="http://download.diuit.com/mime-types.json">standard here</a>.
///
/// \param meta (Optional) Any extra information of this message.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
- (void)sendCustomMessage:(NSString * _Nonnull)data mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
@end


/// Type of chat rooms.
///
/// <ul><li>Direct: Chat room for one-to-one message, only allow two members.</li><li>Group: General chat room. Members can operate join, leave or kick.</li></ul>
typedef SWIFT_ENUM(NSInteger, DUChatType) {
  DUChatTypeDirect = 0,
  DUChatTypeGroup = 1,
};

enum DUDevicePlatform : NSInteger;


/// Class for device in Diuit API.
SWIFT_CLASS("_TtC11DUMessaging8DUDevice")
@interface DUDevice : NSObject

/// Device id.
@property (nonatomic, readonly) NSInteger id;

/// Device serial.
@property (nonatomic, readonly, copy) NSString * _Null_unspecified serial;

/// Any extra information of this device.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;

/// Platform type of this device.\See 
///
/// <code>DUDevicePlatform
/// </code>
@property (nonatomic, readonly) enum DUDevicePlatform platform;

/// Push notification token of this device.
@property (nonatomic, readonly, copy) NSString * _Nullable pushToken;
@end


/// Enum for device platform. You must set this value right to receive push notification correctly.
///
/// <ul><li>Android:       Android.</li><li>IOSSandbox:    Use this value if you are using sandbox certification of push notfication.</li><li>IOSProduction: Use this value if you are using sandbox certification of push notfication.</li><li>NotDefined:    Others platform.</li></ul>
typedef SWIFT_ENUM(NSInteger, DUDevicePlatform) {
  DUDevicePlatformAndroid = 0,
  DUDevicePlatformIOSSandbox = 1,
  DUDevicePlatformIOSProduction = 2,
  DUDevicePlatformNotDefined = 3,
};


/// Encoding schema of messages
typedef SWIFT_ENUM(NSInteger, DUEncoding) {

/// UTF8 encoding, for plain text.
  DUEncodingutf8 = 0,

/// BASE64 encoding, for files or images (deprecated).
  DUEncodingbase64 = 1,

/// Binary encoding, for files or images.
  DUEncodingbinary = 2,

/// JSON encoding, this is used by system message.
  DUEncodingjson = 3,
};

enum DUMessageStatus : NSInteger;
@class DUUser;


/// Class for messages in Diuit API.
SWIFT_CLASS("_TtC11DUMessaging9DUMessage")
@interface DUMessage : NSObject

/// Message id.
@property (nonatomic, readonly) NSInteger id;

/// Mesage mime type. Follow the standard here. A system message's mime is "application/diuit-chat-sys-message"
@property (nonatomic, readonly, copy) NSString * _Nullable mime;

/// Encoding type, such as binary or utf8.
@property (nonatomic, readonly, copy) NSString * _Nullable encoding;

/// Message content.
@property (nonatomic, readonly, copy) NSString * _Nullable data;

/// Message created time.
@property (nonatomic, readonly, strong) NSDate * _Nullable createdAt;

/// Message status of delivering, or receiving.
@property (nonatomic, readonly) enum DUMessageStatus status;

/// The DUChat object that this message belongs to.
@property (nonatomic, readonly, weak) DUChat * _Nullable chat;

/// The user who sends the message. If this message is a system message, snderUser will be nil.
@property (nonatomic, readonly, strong) DUUser * _Nullable senderUser;

/// Any extra information of this message.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;

/// User serials of users who have read this message.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable reads;

/// For outgoing file and video messges, this property indicates the local path of media resource.
@property (nonatomic, copy) NSString * _Nullable localMediaPath;

/// For outgoing image message, this property holds the source UIImage object.
@property (nonatomic, strong) UIImage * _Nullable localImage;

/// Mark a message as read status. The 'reads' property will be automatically update once the task completes successfully.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will the self.
- (void)markAsReadOnCompletion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;
@end


/// This enum indicates the delivery/receiving status of a message.
///
/// <ul><li>NotDelivered: The message object is created but not sent out yet.</li><li>Delivered:    The message is delivered.</li><li>FailedToSend: The message failed to be sent.</li><li>Received:     This message is an incoming message.</li></ul>
typedef SWIFT_ENUM(NSInteger, DUMessageStatus) {
  DUMessageStatusNotDelivered = 0,
  DUMessageStatusDelivered = 1,
  DUMessageStatusFailedToSend = 2,
  DUMessageStatusReceived = 3,
};

@class NSData;
enum DUOrder : NSInteger;


/// Basic class of Diuit Messaging API, provides different static methods to help you manage instances of DUChat, send direct messages and retrieve list of DUAnnounce.
///
/// \param currentUser The user instance (<em>DUUser</em>) currently logged in. This parameter will be nil while not logged in.
///
/// \param currenDevice The device instance (<em>DUDevice</em>) currently logged in. This parameter will be nil while not logged in.
///
/// \param isConnected The connectivity between local device and  Diuit API server
SWIFT_CLASS("_TtC11DUMessaging11DUMessaging")
@interface DUMessaging : NSObject

/// Current logged in DUUser object.
+ (DUUser * _Nullable)currentUser;
+ (void)setCurrentUser:(DUUser * _Nullable)value;

/// Current logged in DUDevice objet.
+ (DUDevice * _Nullable)currentDevice;
+ (void)setCurrentDevice:(DUDevice * _Nullable)value;
+ (BOOL)isConnected;
+ (void)setIsConnected:(BOOL)value;

/// Set you App Id and App Key to your Diuit API framework.
///
/// <h2>Example</h2>
/// <code>DUMessaging.set(appId: "yourAppId", appKey: "yourAppKey")
/// 
/// </code>\Important 
/// 
/// This is the first method you should call. It's supposed to be set in your AppDelegate.swift of AppDelegate.m
///
/// \param appId App Id of your application. You can get it from <a href="http://developer.diuit.com/dashboard">Diuit API Dashboard</a>
///
/// \param appKey App Key of your application. You can get it from <a href="http://developer.diuit.com/dashboard">Diuit API Dashboard</a>
+ (void)setWithAppId:(NSString * _Nonnull)appId appKey:(NSString * _Nonnull)appKey;

/// Auth your device with the session token retrieved from Diuit API server. Because we do not own your credential, you have to let your server authenticate device's identity. Then your server do an extra authentication with Diuit API server. Finally, pass the resulting session token (which will be a string like "1f4e5e4f01736f6d07a9db252ad4e90f") back to the device and send to this method. For example, your server may have a signin API. When this API is called by some device from APP and passed the authentication. Your server then should do second authentication with Diuit API server and a session token will be returned. In the end, you can wrap this session token in your login API response and device is able to receive it. If you have any difficulties in retrieving session tokens, please check development guide for assistance.
///
/// <h2>Example</h2>
/// <code>DUMessaging.authWithSessionToken("sessionToken") { error, result in
///     guard error == nil else {
///         // Handle error
///         return
///     }
///     // Do something here
///     print("My user serial is : \(DUMessaging.currentUser!.serial)")
/// }
/// 
/// </code>\Important 
/// 
/// It's highly recommended to retrieve the session token in your server instead of doing it in APP. We DO NO OWN your credentail, so you must authenticate the identity from each device on your server.
///
/// \param token The session token retrieved from Diuit API server.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and [String: AnyObject] Dictionary. Former will not be nil when there's any error happening; later will describe the information of device and user from Diuit API server's database.
+ (void)authWithSessionToken:(NSString * _Nonnull)token completion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;

/// Update your push token on Diuit API server from device. This must be done when you'd like to receive push notification. You can do it whether you are logged in or not. If you have not logged in, this information will be cached and updated right after you log in.
///
/// <h2>Example</h2>
/// <code>func application( application: UIApplication!, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: NSData! ) {
/// 
///     let characterSet: NSCharacterSet = NSCharacterSet( charactersInString: "<>" )
/// 
///     let deviceTokenString: String = ( deviceToken.description as NSString )
///         .stringByTrimmingCharactersInSet( characterSet )
///         .stringByReplacingOccurrencesOfString( " ", withString: "" ) as String
/// 
///     DUMessaging.setPushTokenFromString("yourPushToken") { error, result in
///         guard error == nil else {
///             // Handle error
///             return
///         }
///         print(result["message"])
///     }
/// 
/// }
/// 
/// </code>
/// \param token Device's push token in String
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and [String: AnyObject] Dictionary. Former will not be nil when there's any error happening; later will be a message of updating results.
+ (void)setPushTokenFromString:(NSString * _Nonnull)token completion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;

/// Update your push token on Diuit API server from device. This must be done when you'd like to receive push notification. You can do it whether you are logged in or not. If you have not logged in, this information will be cached and updated right after you log in.
///
/// <h2>Example</h2>
/// <code>func application( application: UIApplication!, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: NSData! ) {
///    DUMessaging.setPushTokenFromData(deviceToken!) { error, result in
///        guard error == nil else {
///            // Handle error
///            return
///        }
///        print(result["message"])
///    }
/// }
/// 
/// </code>
/// \param token Device's push token in NSData, the original data type you get in AppDelegate
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and [String: AnyObject] Dictionary. Former will not be nil when there's any error happening; later will be a message of updating results.
+ (void)setPushTokenFromData:(NSData * _Nonnull)token completion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;

/// It's your obligation to sychronize your badge number at local side with the server side. After your reduce your badge number due to reasons such as messages being read, you must sync your new badge number with Diuit API server. You can customize your push notification sent by Diuit API server and also the badge number. "increment" will make your badge number increment as long as your local badge number is identical to the server one.
///
/// This method also works when you have not logged in, the badge number will be updated right after you log in.
///
/// <h2>Example</h2>
/// <code>// Assume that your badge number is 5, and two unread messages just got marked as read.
/// // Therefore your badge decreases to 3.
/// DUMessaging.setBadge(3, completion: nil)
/// 
/// </code>
/// \param badge The badge number.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and [String: AnyObject] Dictionary. Former will not be nil when there's any error happening; later will be a message of updating results.
+ (void)setBadge:(NSInteger)badge completion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;

/// This method creates a new group chat room (DUChat) with given members, meta and white list.
///
/// <h2>Example</h2>
/// <code>// You are "user.0"
/// DUMessaging.createChatRoomWith(["user.1", "user.2"], meta: ["name": "Party All Night!"], whiteList: ["user.0", "user.1", "user.2"]) { error, chat in
///     guard error == nil else {
///         // Handle error
///         return
///     }
///     print("Your new chat id is \(chat!.id)")
/// }
/// 
/// </code>\See 
/// <code>createDirectChatWith
/// </code>, method to create a direct chat room
///
/// \param members User serials of the users you'd like to be grouped with. <em>DO NOT</em> add your user serial in this array.
///
/// \param meta (Optional) Any extra information of this chat room, such as a name. It accepts all kinds of data as long as it's a [String: AnyObject] Dictionary.
///
/// \param whiteList User can only join this chat room as long as his user serial exists in this list. Set to nil to allow every one to join.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUChat instance. Former will not be nil when there's any error happening; later will be the instance of newly created chat room.
+ (void)createChatRoomWith:(NSArray<NSString *> * _Nonnull)members meta:(NSDictionary<NSString *, id> * _Nullable)meta whiteList:(NSArray<NSString *> * _Nullable)whiteList completion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;

/// Join any chat room with its id as long as you are allowed to. You will recevie a permission-denied error if you are not on the white list of the chat room.
///
/// <h2>Example</h2>
/// <code>DUMessaging.joinChatRoom(withId:999) { error, chat in
///     guard error == nil else {
///         // Handle error
///         return
///     }
///     print("You've just joined room #\(chat!.id)")
/// }
/// 
/// </code>\Important 
/// 
/// You can not operate this function in a <em>direct message chat room</em>. If you do so, you will receive a operation-not-supported error (480).
///
/// \param chatId The id of the chat room.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUChat instance. Former will not be nil when there's any error happening; later will be the instance of the chat room.
+ (void)joinChatRoomWithId:(NSInteger)chatId completion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;

/// List all your chatrooms, including group chat rooms and direct chat rooms.
///
/// <h2>Example</h2>
/// <code>DUMessaging.listAllChatRooms() { error, chats in
///     guard error == nil else {
///         // Handle error
///         return
///     }
///     print("I have \(chats!.count) chat rooms")
/// }
/// 
/// </code>
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and an Array of DUChat. Former will not be nil when there's any error happening; later will be an Array of DUChat which you are in.
+ (void)listAllChatRooms:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUChat *> * _Nullable))completion;

/// List all your direct chat rooms or group chat rooms corresponding to given argument.
///
/// <h2>Example</h2>
/// <code>DUMessaging.listChatRooms(withType: .Group) { error, chats in
///     guard error == nil else {
///         // Handle error
///         return
///     }
///     print("I have \(chats!.count) group chat rooms.")
/// }
/// 
/// </code>
/// \param type Either direct chat room or group chat room.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and an Array of DUChat. Former will not be nil when there's any error happening; later will be an Array of DUChat which you are in.
+ (void)listChatRoomsWithType:(enum DUChatType)type completion:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUChat *> * _Nullable))completion;

/// You can get a single chat room detail by querying with chat room id
///
/// \param chatId The id of the chat room that you want to look up with
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and an instance of DUChat. Former will not be nil when there's any error happening; later will be the result that you want.
+ (void)chatRoomDetailOf:(NSInteger)chatId completion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;

/// This method creates a new direct chat room (DUChat) with given member and meta. Direct chat does not support kick, join, leave and update white list. This is a special chat room with only two members, aiming for one-to-one communication.
///
/// <h2>Example</h2>
/// <code>DUMessaging.createDirectChatRoomWith("myFriendSerial") { error, chat in
///     guard error == nil else {
///         // Handle error
///         return
///     }
///     // This will receive an error of operation-not-supported
///     chat.leaveOnCompletion() { error, result in
///         print(error!.localizedDescription)
///     }
/// }
/// 
/// </code>\See 
/// <code>createChatWith
/// </code>, method to create a group chat room
///
/// \param member Target user serial
///
/// \param meta (Optional) Any extra information of this chat room, such as a name. It accepts all kinds of data as long as it's a [String: AnyObject] Dictionary.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUChat instance. Former will not be nil when there's any error happening; later will be the instance of newly created chat room.
+ (void)createDirectChatRoomWith:(NSString * _Nonnull)member meta:(NSDictionary<NSString *, id> * _Nullable)meta completion:(void (^ _Nullable)(NSError * _Nullable, DUChat * _Nullable))completion;

/// You can block some user to refuse any direct message exchanging between you two. Note that you still can talk to this user in other group chat rooms.\See 
///
/// <code>unblock
/// </code>, to unblock user.
///
/// \param userSerial User serial of the target user.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a nil object. Former will not be nil when there's any error happening; later will always be nil.
+ (void)block:(NSString * _Nonnull)userSerial completion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;

/// You can unblock some user to restart direct message exchanging between you two.\See 
///
/// <code>block
/// </code>, method to block user.
///
/// \param userSerial User serial of the target user.
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a nil object. Former will not be nil when there's any error happening; later will always be nil.
+ (void)unblock:(NSString * _Nonnull)userSerial completion:(void (^ _Nullable)(NSError * _Nullable, NSDictionary<NSString *, id> * _Nullable))completion;

/// You can directly send a direct (one-to-one) text message to target user via this function. You will receive an error of permission denied as long as you are blocked.
///
/// <h2>Example</h2>
/// <code>DUMessaging.sendDirectText(toUser: "myFriendSerial",
///    text: "Let's dinner @ Mircrosoft",
///    meta: ["event":"https://www.facebook.com/events/123130617869478"],
///    pushMessage: "Dinner Invitation",
///    beforeSend: { message in
///        // deal with the message before sending out ( sucah as refresh UI)
///    }) { error, message in
///        // message is delivered and updated with server-side information, such as id, createdAt and etc..
///    }
/// 
/// </code>\Important 
/// 
/// If your push notification is well set, your text message will be sent along with a piece of push notification. The content of the notification will be the same as your text message. You can customize your content of the notification if you want.\See 
///
/// <code>sendDirectImage
/// </code>, <code>snedDirectFile
/// </code> and <code>sendDirectCustomMessage
/// </code>
///
/// \param serial User serial of the target user.
///
/// \param text Your message content.
///
/// \param meta (Optional) Any extra information of this message.
///
/// \param pushMessage (Optional) Customize content of push notification.
///
/// \param pushPayload (Optional) Extra infromation in your push notification.
///
/// \param badge (Optional) Badge number of push notification; default is "increment", which adds your current badge number by 1, if you correctly set your number on Diuit API server.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
+ (void)sendDirectTextToUser:(NSString * _Nonnull)serial text:(NSString * _Nonnull)text meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// You can directly send a direct (one-to-one) image message to target user via this function. You will receive an error of permission denied as long as you are blocked.
///
/// <h2>Example</h2>
/// <code>DUMessaging.sendDirectText(toUser: "myFriendSerial",
///     image: myImage,
///     pushMessage: "You've to an image message",
///     beforeSend: { message in
///        // deal with the message before sending out ( sucah as refresh UI)
///     }) { error, message in
///        // message is delivered and updated with server-side information, such as id, createdAt and etc..
///     }
/// 
/// </code>\Important 
/// 
/// Your image message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that your file can not be larger than 5 MB.\See 
///
/// <code>sendDirectText
/// </code>, <code>snedDirectFile
/// </code> and <code>sendDirectCustomMessage
/// </code>
///
/// \param serial User serial of the target user.
///
/// \param image Your image.
///
/// \param mime MIME type string based on your image file extension. We provide <code>DUMIMEType
/// </code> for all image extensions supported by UIImage.
///
/// \param meta (Optional) Any extra information of this message.
///
/// \param pushMessage (Optional) Customize content of push notification.
///
/// \param pushPayload (Optional) Extra infromation in your push notification.
///
/// \param badge (Optional) Badge number of push notification; default is "increment", which adds your current badge number by 1, if you correctly set your number on Diuit API server.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
+ (void)sendDirectImageToUser:(NSString * _Nonnull)serial image:(UIImage * _Nonnull)image mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// You can directly send a direct (one-to-one) file message to target user via this function. You will receive an error of permission denied as long as you are blocked.
///
/// <h2>Example</h2>
/// <code>let filePath = NSTemporaryDirectory() + "example.pdf"
/// DUMessaging.sendDirectFile(toUser: "myFriendSerial",
///    path: filePath,
///    meta: ["name":"example.pdf"],
///    pushMessage: "You've got a pdf"),
///    beforeSend: { message in
///        // deal with the message before sending out ( sucah as refresh UI)
///    }) { error, message in
///        // message is delivered and updated with server-side information, such as id, createdAt and etc..
///    }
/// 
/// </code>\Important 
/// 
/// Your file message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that your file can not be larger than 5 MB.\See 
///
/// <code>sendDirectText
/// </code>, <code>snedDirectImage
/// </code> and <code>sendDirectCustomMessage
/// </code>
///
/// \param serial User serial of the target user.
///
/// \param path Your file path.
///
/// \param meta (Optional) Any extra information of this message. You can pass the file name here.
///
/// \param pushMessage (Optional) Customize content of push notification.
///
/// \param pushPayload (Optional) Extra infromation in your push notification.
///
/// \param badge (Optional) Badge number of push notification; default is "increment", which adds your current badge number by 1, if you correctly set your number on Diuit API server.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
+ (void)sendDirectFileToUser:(NSString * _Nonnull)serial mime:(NSString * _Nonnull)mime path:(NSString * _Nonnull)path meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// You can directly send a direct (one-to-one) custom message to target user via this function. You will receive an error of permission denied as long as you are blocked.
///
/// <h2>Example</h2>
/// <code>DUMessaging.sendDirectCustomMessage(toUser: "myFriendSerial",
///    data: "Customized message",
///    mime:"application/my-mime",
///    pushMessage: "You've got a custom message"),
///    beforeSend: { message in
///        // deal with the message before sending out ( sucah as refresh UI)
///    }) { error, message in
///        // message is delivered and updated with server-side information, such as id, createdAt and etc..
///    }
/// 
/// </code>\Important 
/// 
/// Your custom message will not be sent along with a piece of push notification unless you specify the content of the notification. Note that your message size can not be larger than 5 MB.\See 
///
/// <code>sendDirectText
/// </code>, <code>snedDirectImage
/// </code> and <code>sendDirectFile
/// </code>
///
/// \param serial User serial of the target user.
///
/// \param data Your message content.
///
/// \param mime Your message mime type. It's hight recommened that you follow <a href="http://download.diuit.com/mime-types.json">the standard</a>.
///
/// \param meta (Optional) Any extra information of this message. You can pass the file name here.
///
/// \param pushMessage (Optional) Customize content of push notification.
///
/// \param pushPayload (Optional) Extra infromation in your push notification.
///
/// \param badge (Optional) Badge number of push notification; default is "increment", which adds your current badge number by 1, if you correctly set your number on Diuit API server.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
+ (void)sendDirectCustomMessageToUser:(NSString * _Nonnull)serial data:(NSString * _Nonnull)data mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta pushMessage:(NSString * _Nullable)pushMessage pushPayload:(NSDictionary<NSString *, id> * _Nullable)pushPayload badge:(id _Nullable)badge beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// You can directly send a direct (one-to-one) text message to target user via this function. You will receive an error of permission denied as long as you are blocked.\Important 
///
/// 
/// If your push notification is well set, your text message will be sent along with a piece of push notification. The content of the notification will be the same as your text message. You can customize your content of the notification if you want.\See 
///
/// <code>sendDirectImage
/// </code>, <code>snedDirectFile
/// </code> and <code>sendDirectCustomMessage
/// </code>
///
/// \param serial User serial of the target user.
///
/// \param text Your message content.
///
/// \param meta Any extra information of this message.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
+ (void)sendDirectTextToUser:(NSString * _Nonnull)serial text:(NSString * _Nonnull)text meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// You can directly send a direct (one-to-one) image message to target user via this function. You will receive an error of permission denied as long as you are blocked.\Important 
///
/// 
/// Sending image via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that your file can not be larger than 5 MB.\See 
///
/// <code>sendDirectText
/// </code>, <code>snedDirectFile
/// </code> and <code>sendDirectCustomMessage
/// </code>
///
/// \param serial User serial of the target user.
///
/// \param image Your image.
///
/// \param mime MIME type string based on your image file extension. We provide <code>DUMIMEType
/// </code> for all image extensions supported by UIImage. Default value would be JPEG (Swift only).
///
/// \param meta Any extra information of this message.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
+ (void)sendDirectImageToUser:(NSString * _Nonnull)serial image:(UIImage * _Nonnull)image mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// Directly send a file as direct (one-to-one) message to target user via this function. In this function, the MIME type will be set to application/octet-stream in default, you can also use your customize value. You will receive an error of permission denied as long as you are blocked.\Important 
///
/// 
/// Sending file via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that your file can not be larger than 5 MB.\See 
///
/// <code>sendDirectText
/// </code>, <code>snedDirectImage
/// </code> and <code>sendDirectCustomMessage
/// </code>
///
/// \param serial User serial of the target user.
///
/// \param path Your file path.
///
/// \param meta Any extra information of this message. You can pass the file name here.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
+ (void)sendDirectFileToUser:(NSString * _Nonnull)serial mime:(NSString * _Nonnull)mime path:(NSString * _Nonnull)path meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// You can directly send a direct (one-to-one) custom message to target user via this function. You will receive an error of permission denied as long as you are blocked.\Important 
///
/// 
/// Sending file via this function <em>WILL NOT</em> trigger push notification, unless you specify the content of the notification. Note that your data length can not be longer than 5 MB.\See 
///
/// <code>sendDirectText
/// </code>, <code>snedDirectImage
/// </code> and <code>sendDirectFile
/// </code>
///
/// \param serial User serial of the target user.
///
/// \param data Your message content.
///
/// \param mime Your message mime type. It's hight recommened that you follow <a href="http://download.diuit.com/mime-types.json">the standard</a>.
///
/// \param meta Any extra information of this message. You can pass the file name here.
///
/// \param beforeSend Before message sends out, you will get a <code>DUMessage
/// </code> object
///
/// \param completion The closure object to be executed when the task finishes successfully. It will return an NSError and a DUMessage object. Former will not be nil when there's any error happening; later will an instance of DUMessage, your newly created message.
+ (void)sendDirectCustomMessageToUser:(NSString * _Nonnull)serial data:(NSString * _Nonnull)data mime:(NSString * _Nonnull)mime meta:(NSDictionary<NSString *, id> * _Nullable)meta beforeSend:(void (^ _Nullable)(DUMessage * _Nonnull))beforeSend completion:(void (^ _Nullable)(NSError * _Nullable, DUMessage * _Nullable))completion;

/// This function helps your retrieve last 20 announcements. You can set keywords as query condition. The result can be listed by creadted or updated time in ascending or descending order based on the enum (DUOrder) you give.
///
/// Announcements can only be created, updated or deleted from the server side.
///
/// \param keywords Keywords for querying announcements. Set to nil if you want to list all announcements
///
/// \param orderBy Rules of list order.
///
/// \param completion completion: The closure object to be executed when the task finishes successfully. It will return an NSError and a [DUAnnounce] object. Former will not be nil when there's any error happening; later will an Array of DUAnnounce, your query result.
+ (void)listAnnouncesWithKeywords:(NSString * _Nullable)keywords orderBy:(enum DUOrder)orderBy completion:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUAnnounce *> * _Nullable))completion;

/// This function helps your retrieve announcements. You can set keywords as query condition, count for how many announcements in a pgae, and page to indicate which page of announcements to return based on your count number. The result can be listed by creadted or updated time in ascending or descending order based on the enum (DUOrder) you give.
///
/// Announcements can only be created, updated or deleted from the server side.
///
/// \param keywords Keywords for querying announcements. Set to nil if you want to list all announcements
///
/// \param page Page number of announcements to return, starting form 0.
///
/// \param count Number of announcements in a page. Value 20 is recommended.
///
/// \param orderBy Rules of list order.
///
/// \param completion completion: The closure object to be executed when the task finishes successfully. It will return an NSError and a [DUAnnounce] object. Former will not be nil when there's any error happening; later will an Array of DUAnnounce, your query result.
+ (void)listAnnouncesWithKeywords:(NSString * _Nullable)keywords page:(NSInteger)page count:(NSInteger)count orderBy:(enum DUOrder)orderBy completion:(void (^ _Nullable)(NSError * _Nullable, NSArray<DUAnnounce *> * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Order types of announcements list.
///
/// <ul><li>CreatedDescending: Order by create time, descneding.</li><li>CreatedAscending: Order by create time, ascneding.</li><li>UpdatedDescending: Order by update time, descneding.</li><li>UpdatedAscending: Order by update time, ascneding.</li></ul>
typedef SWIFT_ENUM(NSInteger, DUOrder) {
  DUOrderCreatedDescending = 0,
  DUOrderCreatedAscending = 1,
  DUOrderUpdatedDescending = 2,
  DUOrderUpdatedAscending = 3,
};


/// Status of typing indicator
///
/// <ul><li>IsTyping: user is typing</li></ul>
typedef SWIFT_ENUM(NSInteger, DUTypingIndicator) {
  DUTypingIndicatorIsTyping = 0,
};



/// Class for user in Diuit API.
SWIFT_CLASS("_TtC11DUMessaging6DUUser")
@interface DUUser : NSObject

/// User id.
@property (nonatomic, readonly) NSInteger id;

/// User serial.
@property (nonatomic, readonly, copy) NSString * _Null_unspecified serial;

/// Any extra information of this user.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;

/// User serials of blocked users.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable blackList;

/// Update user meta.
///
/// \param meta Dictionary object you want to saved in user meta.
///
/// \param completion Completion handler for updating meta.
- (void)updateMeta:(NSDictionary<NSString *, id> * _Nonnull)meta completion:(void (^ _Nullable)(NSError * _Nullable, DUUser * _Nullable))completion;
@end


@interface SocketIOClient (SWIFT_EXTENSION(DUMessaging))
@end


@interface UIImage (SWIFT_EXTENSION(DUMessaging))
@end

#pragma clang diagnostic pop
